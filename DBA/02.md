# PostgreSQL Internal Architecture – Deep Dive, How and Why Things Work

## Where Everything Actually Begins: The Client

- PostgreSQL never works alone. It always reacts to something. That something is a client. The client can be psql, a Java app, a Python service, or anything else using a PostgreSQL driver.

- The important thing to understand is this: PostgreSQL does not know or care about your application logic. It only understands requests like connect, read, write, commit, rollback. Everything starts when a client asks for a connection.

## Why PostgreSQL Needs the Postmaster

- When PostgreSQL starts, it does not immediately start accepting queries. First, it creates a single master process called the postmaster.

- The postmaster exists because PostgreSQL uses a process-per-connection model. Someone needs to control process creation, cleanup, and coordination. That someone is the postmaster.

- If every client created its own process freely, the system would collapse. So the postmaster acts as a gatekeeper. Every connection request must pass through it.

## Connection Request: What Really Happens

- When a client asks for a connection, the postmaster checks whether the server is healthy and whether it can even accept new connections. Then authentication begins.

- Authentication is not hardcoded into PostgreSQL. Instead, PostgreSQL delegates this responsibility. This is why you see PAM, LDAP, Kerberos, and password-based auth. PostgreSQL only asks one question: is this user allowed or not?

- If authentication fails, the request dies here. No backend process is created. This is important because creating processes is expensive.

## Why Backend Processes Exist

- Once authentication succeeds, the postmaster forks a backend process. This backend process belongs to exactly one client.

- PostgreSQL does this because isolation matters. If one query crashes or misbehaves, it should not take down others. Separate OS processes give strong isolation.

- This backend process will now handle everything for that client. Parsing queries, planning them, executing them, managing memory, and coordinating with background processes.

## Memory at Backend Level: Why work_mem Exists

- Each backend process needs its own working area. Imagine running a sort or a join. PostgreSQL needs temporary space to hold intermediate results.

- This is where work_mem comes in. It is not global memory. It is per operation, per backend. If you underestimate this, queries spill to disk and become slow. If you overestimate it, too many backends can eat all system RAM.

- This design exists because PostgreSQL assumes queries can be complex and independent.

## Shared Memory: Why Everyone Shares One Brain

- Now comes shared memory. This is the most critical part of PostgreSQL performance.

- If every backend read data directly from disk, PostgreSQL would be unusable. Disk is slow. Memory is fast. So PostgreSQL keeps frequently used data in shared buffers.

- Shared buffers exist so that one backend’s work benefits others. If one process reads a page, others can reuse it.

- This is why shared_buffers tuning matters so much.

## Why PostgreSQL Writes WAL Before Data

- Here comes a very important question. Why does PostgreSQL write logs first and data later?

- Because disks fail. Systems crash. Power goes off.

- If PostgreSQL directly modified data files and crashed midway, the database would become corrupted. So PostgreSQL uses Write Ahead Logging.

- The rule is simple: describe the change first, apply the change later.

- WAL records describe what changed, not the final state. This makes recovery possible.

## WAL Writer: Why It Is a Separate Process

Writing logs is not optional. It must happen quickly and in order.

The WAL writer exists to flush WAL records from memory to disk efficiently. Backend processes should not block on disk IO more than necessary.

So backends push WAL records into shared memory, and the WAL writer flushes them in batches.

This separation improves throughput and reduces latency.

## Background Writer: Why Dirty Pages Are Delayed

When a backend modifies data, it changes a page in memory. That page becomes dirty.

But PostgreSQL does not rush to write it to disk. Writing to disk is expensive. Instead, it lets dirty pages accumulate.

The background writer slowly pushes dirty pages to disk in the background. This smooths IO spikes and keeps performance stable.

Without this process, every write query would block waiting for disk.

## Checkpoint: Why PostgreSQL Needs a Reset Point

Over time, WAL grows. Dirty pages accumulate. PostgreSQL needs a point where it can say, “everything before this is safely on disk.”

That point is called a checkpoint.

At a checkpoint, PostgreSQL forces dirty pages to disk and records the checkpoint in WAL. After this, recovery only needs to replay WAL after the checkpoint.

This dramatically reduces crash recovery time.

## Why MVCC Exists at All

Locks are expensive. If readers block writers and writers block readers, concurrency dies.

PostgreSQL avoids this using MVCC. Instead of overwriting rows, PostgreSQL creates new versions.

Readers see old versions. Writers create new ones. Visibility is controlled using transaction IDs.

This design allows high concurrency at the cost of extra storage and cleanup.

## Autovacuum: The Janitor Nobody Notices

MVCC creates dead rows. If they are never cleaned, tables grow endlessly.

Autovacuum exists to reclaim space and keep statistics fresh. It is not optional. Turning it off is self-sabotage.

It runs quietly, cleaning dead tuples and updating planner statistics.

## How Data Is Actually Stored on Disk

PostgreSQL stores data in fixed-size pages. Each page contains multiple rows.

Pages are the unit of IO. PostgreSQL never reads a single row from disk. It always reads the entire page.

This is why table bloat and page layout matter.

## Why Indexes Help and Hurt

Indexes speed up reads by reducing page scans. But they increase write cost.

Every insert or update must update indexes. As data grows, indexes grow, memory pressure increases, and IO increases.

This is why blindly adding indexes is dangerous.

## CPU, Memory, and Disk: The Real Bottlenecks

CPU load increases with connections, planning, and MVCC checks.

Memory pressure increases with work_mem usage, shared_buffers size, and index caching.

Disk becomes the bottleneck when WAL flushes, checkpoints, or random IO dominate.

Understanding internals helps you identify which one is hurting.

## Final Mental Model

PostgreSQL is a carefully balanced system. Processes isolate failures. Shared memory enables speed. WAL guarantees safety. Background workers smooth IO. MVCC enables concurrency.

Nothing exists without a reason. Every component solves a specific problem that appears at scale.

Once you understand this, PostgreSQL stops being magic and starts being predictable.
