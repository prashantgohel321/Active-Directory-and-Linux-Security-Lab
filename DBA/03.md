# PostgreSQL Internal Architecture – From Absolute Zero to Deep Internal Understanding


## What PostgreSQL Actually Is

PostgreSQL is not a library. It is not a single binary doing magic. PostgreSQL is a full database server.

That means it is a long‑running program that sits on a machine, listens on a network port, accepts requests, manages memory, writes to disk, recovers from crashes, and protects data from corruption.

So the first thing to accept is this: PostgreSQL behaves more like an operating system for data than a simple application.

---

## Everything Starts Outside PostgreSQL: The Client

PostgreSQL never initiates work. It always reacts.

The reaction starts when a client tries to connect.

A client can be psql, a Java application, a Python service, or anything else that understands the PostgreSQL wire protocol. The client’s job is very simple. It sends bytes over the network saying, “I want to connect” or “I want to run this query”.

At this point, PostgreSQL does not trust the client at all.

---

## How the Connection Reaches PostgreSQL

PostgreSQL listens on a TCP port. Usually 5432.

When a client opens a TCP connection to this port, the operating system accepts it first. Then the OS hands this connection to the PostgreSQL server process that is listening.

That listening process is called the postmaster.

---

## Why the Postmaster Exists

PostgreSQL uses one operating system process per client connection.

Creating processes is expensive. Managing them is complex. Allowing random code paths to create processes would destroy stability.

So PostgreSQL centralizes all control in one parent process called the postmaster.

The postmaster does not execute queries. It manages life and death.

It decides:

Can a new connection be accepted?
Is the server shutting down?
Is the system in recovery?
Can resources handle one more backend process?

Without the postmaster, PostgreSQL would turn into chaos.

---

## Authentication: Trust Is Earned, Not Assumed

When a client requests a connection, the postmaster does not immediately create a backend process.

First, authentication must succeed.

PostgreSQL itself does not reinvent authentication. Instead, it integrates with existing systems.

This is why you see authentication methods like password, PAM, LDAP, Kerberos, or certificates.

The file that controls who is allowed to connect, from where, and using which method is pg_hba.conf.

This file answers questions like:

Which user can connect?
From which IP address?
To which database?
Using what authentication method?

If the rules in pg_hba.conf do not match, the connection is rejected immediately.

---

## How PostgreSQL Knows a User Is Valid

PostgreSQL has internal system catalogs. These are tables that store metadata.

User accounts are stored internally as roles.

When authentication happens, PostgreSQL checks:

Does this role exist?
Is it allowed to log in?
Does the authentication method confirm identity?

Only after all these checks pass does PostgreSQL trust the user.

---

## Where PgBouncer Fits (And Why It Exists)

PgBouncer is not PostgreSQL. It is a separate connection pooler.

Why does it exist?

Because PostgreSQL creates one OS process per connection. Thousands of connections mean thousands of processes. That kills memory and CPU.

PgBouncer sits between clients and PostgreSQL.

Clients connect to PgBouncer. PgBouncer maintains a small, controlled number of actual PostgreSQL connections.

PgBouncer decides:

Is a backend connection free?
Should this client wait?
Should this client be rejected?

PgBouncer does not understand SQL deeply. It manages connections, not queries.

---

## Backend Process: The Personal Worker

Once authentication succeeds, the postmaster forks a backend process.

This backend process belongs to exactly one client.

Why?

Isolation.

If one backend crashes, others survive.
If one query consumes too much memory, it does not directly corrupt others.

This backend process will:

Parse queries
Plan queries
Execute queries
Manage transaction state
Interact with shared memory
Coordinate with background processes

---

## Operational Instructions: What Backend Actually Executes

When a client sends SQL, it is just text.

The backend process converts this text into operations.

Operations include:

Reading table pages
Modifying rows
Updating indexes
Writing WAL records
Checking visibility rules

The backend never directly edits disk files randomly. Everything goes through controlled layers.

---

## PostgreSQL Memory Model: Why Memory Is Split

PostgreSQL memory is divided because different problems need different solutions.

There is private memory and shared memory.

---

## Private Memory: Memory Belonging to One Backend

Private memory belongs to one backend process.

The most important private memory areas are work_mem and maintenance_work_mem.

---

## work_mem: Memory for Query Operations

work_mem is used when PostgreSQL needs to sort data, build hash tables, or process joins.

It is allocated per operation, not per session.

This means one query can use work_mem multiple times.

Why it exists:

Sorting on disk is slow.
Hash joins on disk are slow.

work_mem allows PostgreSQL to do these operations in RAM.

---

## maintenance_work_mem: Memory for Heavy Maintenance

maintenance_work_mem is used for operations like:

Creating indexes
Vacuuming tables
Altering large objects

These operations are not part of normal query execution. They are heavier and less frequent.

That is why PostgreSQL separates this memory from work_mem.

---

## Shared Memory: The Common Brain

Shared memory is visible to all backend and background processes.

This is where PostgreSQL keeps data that must be shared safely.

---

## Shared Buffers: Why They Exist

Disk is slow. Memory is fast.

Shared buffers cache data pages read from disk.

If one backend reads a page, another backend can reuse it.

This reduces disk IO and improves performance.

---

## WAL Buffers: Recording History Before Reality

WAL buffers store write‑ahead log records before they are flushed to disk.

Every change is described here first.

This ensures durability and crash safety.

---

## CLOG Buffers: Tracking Transaction State

CLOG stands for commit log.

It tracks whether a transaction is committed, aborted, or in progress.

MVCC depends on this information.

Without CLOG, PostgreSQL could not decide which row versions are visible.

---

## Background Processes: Silent Workers

PostgreSQL runs many background processes. Five are essential to understand.

---

## WAL Writer

Writes WAL records from memory to disk.

Ensures durability without blocking backends too much.

---

## Background Writer

Writes dirty data pages from shared buffers to disk gradually.

Prevents IO spikes.

---

## Checkpointer

Forces a consistent state on disk.

Marks recovery points.

Reduces crash recovery time.

---

## Autovacuum

Cleans dead row versions.

Updates statistics.

Prevents table bloat.

---

## Archiver

Moves WAL files for backup and replication.

---

## Disk Layout: Where Data Lives

All persistent data lives inside the PostgreSQL data directory.

This directory is the heart of PostgreSQL.

---

## Important Configuration Files

postgresql.conf controls server behavior.

pg_hba.conf controls authentication.

pg_ident.conf maps system users to database users.

The fourth critical file is postmaster.pid, which ensures only one server runs.

---

## Heap Tables: Where Rows Actually Live

Heap tables store actual row data.

They are unordered.

Updates create new versions.

---

## Pages: Unit of IO

Data is stored in fixed‑size pages.

Pages contain records.

PostgreSQL reads and writes pages, not rows.

---

## Records: Actual Rows

Records are row versions.

They include transaction metadata.

This enables MVCC.

---

## Workload Types: Understanding Bottlenecks

CPU workload comes from planning, MVCC checks, and concurrency.

Memory workload comes from buffers, work_mem usage, and caching.

Disk workload comes from WAL writes, checkpoints, and page reads.

---

## Final Understanding

PostgreSQL is a system of controlled compromises.

Every component exists because something else would fail without it.

Once you understand the reasons, PostgreSQL becomes predictable, debuggable, and tunable.

This is real understanding, not memorization.
