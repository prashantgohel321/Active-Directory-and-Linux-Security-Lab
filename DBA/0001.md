# PostgreSQL Internal Architecture – From Client to Backend Process (Extreme Deep Dive)

## The World Before PostgreSQL Is Even Involved

Everything starts outside PostgreSQL. PostgreSQL does not wake up and ask for work. It only reacts. Somewhere, an application exists. That application could be psql, a Java service, a Python script, or anything else. At some moment, the application decides it needs data. To get that data, it must talk to PostgreSQL.

The application does not talk to PostgreSQL directly in human language. It uses a PostgreSQL client library. That library knows how to speak the PostgreSQL network protocol. At this point, PostgreSQL is just a remote service listening on a network port.

When the client decides to connect, the very first thing that happens is not PostgreSQL logic. It is basic networking. The client opens a TCP connection to the server IP and port, usually port 5432. The operating system on the database server accepts this TCP connection and hands it to the PostgreSQL server process that is listening.

Only now does PostgreSQL enter the picture.

## The Postmaster: Why a Single Gatekeeper Must Exist

Inside PostgreSQL, there is exactly one process that listens for new connections. This process is called the postmaster. You can think of it as the root of the entire PostgreSQL process tree.

The postmaster exists because PostgreSQL uses operating system processes, not threads, to handle clients. Creating processes is expensive. Killing processes is expensive. Coordinating them is complex. If every part of PostgreSQL could create processes freely, the system would collapse under its own complexity.

So PostgreSQL centralizes all authority in the postmaster. The postmaster is not a worker. It does not execute queries. Its job is control, coordination, and safety.

When the TCP connection reaches PostgreSQL, the postmaster is the first PostgreSQL process that sees it.

## The First Question PostgreSQL Asks: Should I Even Talk to You?

Before anything else happens, PostgreSQL must decide whether this connection attempt is even allowed to continue. This decision is not based on SQL, tables, or data. It is purely about trust.

PostgreSQL checks its host-based authentication rules. These rules live in a file called pg_hba.conf. This file is not optional. It is the firewall of PostgreSQL.

pg_hba.conf answers very specific questions. From which IP address is this client connecting? Which database does it want? Which user name is it claiming to be? What authentication method should be used for this combination?

If no rule matches, the connection dies here. PostgreSQL does not create any backend process. It does not allocate memory. It simply rejects the client.

This early rejection exists to protect the system. Creating backend processes for unauthorized users would waste resources and open attack surfaces.

## Authentication: Proving Identity, Not Permissions

If pg_hba.conf allows the connection attempt, PostgreSQL moves to authentication. Authentication is about identity, not about what the user can do.

PostgreSQL deliberately does not reinvent authentication mechanisms. Instead, it integrates with existing systems. Depending on configuration, PostgreSQL may ask for a password, talk to PAM, consult LDAP, validate Kerberos tickets, or check client certificates.

At this stage, PostgreSQL is asking a simple question: is the client really who it claims to be?

If authentication fails, the connection ends immediately. Again, no backend process is created. PostgreSQL is very strict here because trust is foundational. Everything else depends on it.

## Role Validation: Does This User Exist Inside PostgreSQL?

Authentication alone is not enough. Even if the external system says the identity is valid, PostgreSQL must check its own internal records.

PostgreSQL stores user accounts as roles in its system catalogs. These catalogs are internal tables that describe PostgreSQL itself.

PostgreSQL checks whether the role exists, whether it is allowed to log in, and whether it is allowed to connect to the requested database. Only if all these checks pass does PostgreSQL accept the user.

At this moment, PostgreSQL finally considers the client to be legitimate.

## Where PgBouncer Fits Into This Story

Sometimes, the client is not talking directly to PostgreSQL. Instead, it is talking to PgBouncer. PgBouncer sits between the client and PostgreSQL as a connection pooler.

PgBouncer exists because PostgreSQL creates one operating system process per connection. Thousands of connections mean thousands of processes. That consumes memory, CPU, and context-switching overhead.

PgBouncer changes the model. Clients connect to PgBouncer. PgBouncer maintains a controlled number of actual PostgreSQL connections.

When a client connects, PgBouncer decides whether an existing PostgreSQL connection can be reused, whether the client must wait, or whether the connection must be rejected. PgBouncer does not deeply understand SQL. It understands connection state.

From PostgreSQL’s point of view, PgBouncer looks like a normal client. PostgreSQL does not know or care that pooling is happening.

## The Birth of a Backend Process

Once authentication and role validation succeed, the postmaster makes a critical decision. It forks a new backend process.

This backend process is dedicated to exactly one client connection. It is not shared. It will live as long as the client stays connected.

PostgreSQL uses process-per-connection because isolation matters. If a backend crashes, it should not corrupt the state of other sessions. Operating system process isolation gives PostgreSQL strong safety guarantees.

The backend process inherits access to shared memory and internal control structures, but it also gets its own private memory space.

This moment is important. From now on, the client is no longer talking to the postmaster. It is talking directly to its own backend process.

## What a Backend Process Actually Is

A backend process is not just a worker. It is a full executor for that client.

It maintains session state, transaction state, memory contexts, and locks. It parses SQL, plans execution strategies, executes operations, and returns results.

Each backend process understands PostgreSQL internals deeply, but it does not act alone. It coordinates constantly with shared memory and background processes.

## Why Multiple Backend Processes Can Exist Safely

You might wonder how hundreds of backend processes can work on the same database without destroying data.

The answer is discipline. Backend processes never write directly to disk files in an uncontrolled way. They follow strict rules, use shared memory, log every change, and respect transaction visibility.

This controlled behavior is what allows concurrency without chaos.

## The End of the Connection

When the client disconnects, the backend process cleans up its session state and exits. The operating system reclaims its memory. Shared resources are released.

The postmaster remains alive, waiting for the next connection.

## What You Should Understand After This File

At this point, you should have a clear mental image of how a client connection becomes a backend process. You should understand why the postmaster exists, why authentication happens before backend creation, why PgBouncer exists, and why PostgreSQL chooses process-based isolation.

Nothing in PostgreSQL happens accidentally. Every step exists because something breaks without it.

In the next file, we will take this same backend process and follow a single SQL query through it, step by step, without breaking the mental flow.
