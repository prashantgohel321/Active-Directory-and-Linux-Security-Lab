# PostgreSQL Internal Architecture (Simple Explanation)

## Introduction

When I build an application that talks to a database, I need a client that can send read and write requests to it. PostgreSQL supports many clients in different languages like Java, Python, Go, etc. My application uses one of these clients to send queries to the PostgreSQL engine running somewhere on the network.

Understanding how PostgreSQL works internally helps me understand how it handles heavy read and write workloads in production.

---

## Client Connection Flow

When my application sends a request, it first asks PostgreSQL for a connection. This request is handled by the **postmaster**, which is the main parent process of PostgreSQL.

The postmaster acts like a coordinator. It manages all other PostgreSQL processes and decides what happens when a new client connects.

---

## Authentication and Connection Pooling

When a connection request arrives:

* PostgreSQL authenticates the user using configured methods like password, LDAP, PAM, or other identity systems.
* After authentication, a **connection pooler** like **PgBouncer** may be involved.

PgBouncer manages how many active connections PostgreSQL can handle. If connections are available, it allows the client to connect. If not, it may reject or queue the request. This protects PostgreSQL from being overloaded.

---

## Backend Process (One Per Client)

Once the connection is accepted:

* The postmaster **spawns a new backend process** for that client.
* Each client gets exactly **one backend process**.

This backend process:

* Parses SQL
* Plans queries
* Executes queries
* Reads and writes data

When the client disconnects, this backend process exits. Backend processes are never shared between clients, which is why too many connections can overwhelm the system.

---

## Memory Architecture

PostgreSQL memory is divided into two main parts:

### Shared Memory

* Used by all backend and background processes
* Contains shared buffers, WAL buffers, and index caches
* Helps reduce disk I/O

### Private Memory

* Belongs to individual backend processes
* Includes work memory used during query execution
* Memory usage increases as connection count increases

This is why connection pooling is essential in PostgreSQL.

---

## Background Processes

PostgreSQL runs multiple background processes to keep the database healthy and durable.

### WAL Writer

* Writes changes to the Write-Ahead Log (WAL)
* Ensures durability
* Allows crash recovery by replaying logs

### Background Writer (BG Writer)

* Writes modified data pages from memory to disk
* Helps smooth out disk I/O

### Checkpointer

* Coordinates WAL writer and background writer
* Forces dirty data to disk at specific points
* Records checkpoints in WAL for faster recovery

### Other Background Processes

* **Autovacuum**: Cleans up dead rows
* **Archiver**: Archives WAL files

These processes run continuously in the background.

---

## Write-Ahead Logging (WAL)

PostgreSQL never writes data directly to disk from a query.

Flow:

1. Changes happen in memory
2. Changes are written to WAL first
3. Data is later flushed to disk

This guarantees durability. If PostgreSQL crashes, it replays WAL logs to recover to a consistent state.

---

## Data Storage on Disk

PostgreSQL stores data in:

* Records (rows)
* Pages (fixed-size blocks)
* Tables (collections of pages)

Pages contain multiple records. Each record has pointers and length metadata so PostgreSQL can navigate efficiently. Pages are organized in heap structures.

---

## Disk Types and Performance

Disk performance directly affects PostgreSQL speed:

* **HDD**: Slower, random access, higher seek time
* **SSD**: Faster, sequential access, lower latency

Higher IOPS disks provide better performance for PostgreSQL workloads.

---

## CPU Workload

CPU usage increases due to:

* High number of connections
* Query execution and planning
* Locking and concurrency control (MVCC)
* Large index maintenance

Connection count should always be tuned according to CPU capacity.

---

## Memory Workload

Memory pressure increases when:

* Queries scan many rows
* Large indexes are used
* Too many backend processes are active

Proper indexing and query optimization are critical to control memory usage.

---

## Disk I/O Workload

Disk I/O becomes a bottleneck when:

* WAL writes increase
* Index sizes grow
* IOPS limits are reached

Solutions:

* Faster disks
* Higher IOPS volumes
* Horizontal or vertical disk scaling

---

## Final Thoughts

PostgreSQL architecture makes its behavior very transparent:

* One process per connection
* Clear memory usage
* Visible disk activity

Understanding CPU, memory, and disk behavior helps me diagnose performance problems and make correct scaling decisions in production environments.
